<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaOOP</title>
    <style>
        .indented {
            text-indent: 1em; /* Adjust the value as needed */
            margin-left: -1em; /* Counteract the text indent to maintain alignment */
        }
    </style>
</head>
<body>

<h1>Java OOP</h1>
<h2>Classes & Objects</h2>
<p>Когато създаваме класове и пишем методи в един клас, ние играем ролята на архитекти и пишем код, който ще се стартира, когато някой извика върху определен обект някакво действие.</p>
<p>Въпроси, които си задавам при създаването на един клас:</p>
<ol>
    <li><strong>Какво представлява?</strong> Как се казва? - ИМЕТО</li>
    <li><strong>Какво има?</strong>	- ХАРАКТЕРИСТИКИТЕ</li>
    <li><strong>Какво прави?</strong>	- МЕТОДИТЕ</li>
    <li><strong>Как се създава?</strong> Какво изисква, за да се създада? Без какво не може обекта от този клас?
        - КОНСТРУКТОРИ с какви параметри да създам</li>
</ol>
<p>Обект е всичко, което можем на наименоваме, дефинираме, покажем на някого - физически или абстрактни неща: вятърът,
    любовта, студът, бъдещето.
    Обектите представляват реална репрезентация на реални неща от реалния свят.
    Всеки обект има определено състояние (списък с х-ки) и определено поведение (действие, което може да извършва).
    Тези действия могат да променят състоянието на други обекти около него.
    STATE (какво има) and BEHAVIOUR (какво прави);
    Така програмата заприличва на симулация - огледало на реалния живот.</p>
<p>Класът е описание на нов референтен тип данни в Java.
    ОБЕКТЪТ Е ИНСТАНЦИЯ НА КЛАСА.
    Обектите са референтен тип данни, като типа на обекта е дефиниран в класа, от който е създаден.
    Обектът е стойност на променлива от тип Класа, от който е инстанциран. Можем да имаме променливи, които да сочат
    към тези обекти.
    <br /><strong>Car opel = new Car();</strong>
    <strong> opel</strong> е променлива в стека, която сочи към обекта в Heap-a (сбор от променливи и методи).
    Този обект е от тип <strong>Car</strong>.
    Класът описва характеристиките и поведението на обектите.</p>
<p>Променлива в класа представлява характеристика на всеки един от обектите, които ще бъдат създадени по образ и
    подобие на този клас.
   <br />Създаването на обекта не може да бъде прекратено. Каквото и да пиша в тялото на конструктора.
    Единствените варианти за това са да застрелям JVM със System.exit() - не се прави или да хвърля exception.

    <br />Когато искаме да достъпим характеристиките (елементите) на даден обект, взимаме референцията,
    която сочи към този обект и с точка достъпваме нейните характеристики.
    <br /><strong>Person ivan = new Person();</strong>
    <br /><strong>Person</strong> - име на класа;
    <br /><strong>ivan</strong> - референция към създадения с new обект от класа Person;
    <br /><strong>new.Person()</strong> - задели памет в хийпа и създай обект от тип Person с референция в стека ivan,
    която да сочи към него.
</p>
<p><strong> Когато дефинирам клас и се обръщам към нещо, за което знам, че е поле на класа, вътре в самия клас го адресирам
    с "this.". По този начин го отличавам от останалите променливи (към метод в класа и пр.).</strong>
</p>
<p><strong></strong>
    <strong>Getters & Setters</strong> са методи (някакъв интерфейс), който създателя на класа предоставя на външните
    ползватели за работа с полетата на класа, като е подсигурил, че няма да се наруши тяхната взаимовръзка от тази работа.
    <br /><strong>Getter</strong> 		- метод в клас, който връща някаква стойност от дадено поле на класа за генерирания обект;
    <br /><strong>Setter</strong> 		- метод в клас, който задава стойност на дадено поле на класа за генерирания обект;
    <br /><strong>Property</strong> 	- характеристика (променлива) в даден клас, заедно с нейния Getter и Setter.
</p>
<p>Класическа подредба при дефиниране на клас:</p>
    <ul>
    <li>най-отгоре полета;</li>
    <li>след това конструктори;</li>
    <li>най-отдолу методи.</li>
    </ul>
<p>Състояние на един обект към даден момент от изпълнение на програмата са стойностите на неговите полета.</p>
<p>Ако дам println на променлива, сочеща към обект, ще получа типа на обекта + @ + hexadecimal на адреса на обекта.</p>

<h2>КОНСТРУКТОРИ:</h2>
<p>Имам default-ния конструктор по подразбиране. Ако създам конструктор с параметри, губя достъп до конструктора по
    подразбиране, докато не го създам (overload-на) изрично. Така, създавайки само конструктори с параметри
    мога да задължа потребителя да задава параметри на обектите при дефинирането им.</p>
<p><strong>Constructor overloading</strong> - дефинирането на повече от един конструктор в един клас с едно и също име,
    но с различни параметри.
    <strong>Constructor chaining</strong> - "навръзването" на конструктори (един конструктор вика друг, за да се
    избегне дублирането на код).
    Обикновено конструктор вика такъв с малко по-тесни функционалности и дописва допълненията.
    Constructor Chaining можем да имаме в рамките на класа или между класове в йерархична връзка (при наследяване -
    децата разширяват конструкторите на родителите си).
    Всички overload-нати конструктори трябва да се различават по брой, тип ИЛИ подредба на параметрите.</p>
<p>
    Чейнинга винаги е на първо място в коструктора. Не мога да добавя неща към нещо, което още не съм създал (в случая
    извикал от предходен конструктор). Викането на предходен конструктор изгражда обекта и описва характеристики, които
    вече съществуват в предходния конструктор. Едва след тях, можем да "допишем" допълнителни характеристики.
</p>
<p>Ключовата дума "this".</p>
    <ul>
        <li>always refers to the current object, върху който се изпълнява действието;</li>
        <li>this (parameter1, parameter2) 	- използва се при Constructor chaining; Извиква съществуващ конструктор с
        посочените параметри и изпълнява тялото му в настоящия конструктор, за да не повтаряме код.</li>
        <li>в конструктора чрез this. достъпвам променливите на класа, за да избегна shadowing от променливи в параметрите
        на конструктора със същото име (this.name = name;). <br /> this.name е името на клас-променливата,
        name е името на променливата, подадена в конструктора. </li>
        <li>ако в характеристиките на класа подаваме клас от същия тип, напр. Person friend;, в конструктора мога да го
        извикам като  friend = this;, т.е. приятел е на самият себе си.</li>
        <li>не мога да подам нова стойност на this (this = null, например), защото this сочи само към текущия обект и няма
        как да започне да сочи към нищо друго.</li>
    </ul>
<p>Правила при конструкторите:</p>
    <ul>
        <li>не мога да извикам два конструктора или един конструктор повече от веднъж в даден конструктор.</li>
        <li>извикването в конструктор на друг конструктор може да бъде само и единствено на първо място в тялото;</li>
    </ul>

<p>Мога да използвам setter в конструктора, когато покриват една и съща характеристика. Така няма да повтарям една
    и съща валидация на две места.</p>
<p>Метода може да върне само една стойност, вкл. и getter-а. Ако искам да върна две стойности, трябва да връщам
    тип Object[] - масив от обекти, защото всяко нещо е обект (наследяване и полиморфизъм).</p>
<h2>ЧЕТИРИТЕ   ПРИНЦИПА   НА   ООП :</h2>
<p>КАПСУЛАЦИЯ 		-	ENCAPSULATION
<br />НАСЛЕДЯВАНЕ		-	INHERITANCE
<br />АБСТРАКЦИЯ		-	ABSTRACTION
<br />ПОЛИМОРФИЗЪМ	    -	POLYMORPHISM</p>

<h2>К А П С У Л А Ц И Я :	</h2>
<p>Модификатори за достъп - инструментите, чрез които реализираме капсулацията. Те са ключови думи, които слагаме в
    декларацията на конструктор, метод, променлива или клас: (public, private, default, protected);</p>
    <ul>
        <li><strong>	- private</strong> 	- ключова дума, която описва, че до полето след нея достъп ще има само
            самия клас, в който то се намира. Ползват го само методи и конструктори на класа и никой извън класа няма
            достъп до него.</li>
        <li><strong> - default</strong> 	- не е ключова дума. Просто не се пише нищо пред полето. Дефолтният модификатор
            указва, че до полето имат достъп текущият клас и всички други класове в текущия пакет.</li>
        <li><strong> - protected</strong>	- защитените полета и методи са видими в рамките на класа, в рамките на
            текущия пакет и за децата на класа (независимо в коя папка се намират те);</li>
        <li><strong> - public </strong> 	- поставя се пред поле и го прави публично (достъпно от целия проект,
            независимо в какъв пакет се намираме).</li>
    </ul>
<p>Добра практика: всичко е private, докато някой не проплаче, че му трябва достъп. Като направя всички характеристики
    private, веднага лъсват security breaches, където някой е направил пряк достъп до променлива.
    Защото прекия достъп до променлива е неконтролиран достъп, който не мога по никакъв начин да валидирам.
    Avoid at all cost!
    <br /> Класовете могат да бъдат само public или default.
    <br /> Всички останали модификатори за достъп мога да поставя на характеристика, на конструктор, на методи.</p>

<h4>FINAL</h4>
<p> <strong> final</strong> - ключова дума. Поставя се пред променлива, която веднъж инициализирана, до края на
    живота си (в блока код) не трябва да променя стойността си и обратното би било пагубно за логиката.
    <br />Final променлива - променлива, която веднъж инициализирана, повече не може да променя стойността си.
    <br />Мога ли на final референтна променлива да пипам характеристиките? Мога. Но не мога да подменя адреса, не мога
    да я накарам да сочи към друго място, друг адрес, друга променлива.
    <br />Final клас променлива може да се инициализира или още при декларация (но тогава стойноста й е предварително
    зададена за всички бъдещи обекти), или в конструктор, защото той се изпълнява само веднъж.
    <br />Разбира се, не може и при двете - това би довело до повторна инициализация.
    Final променливата задължително трябва да бъде инициализирана. Веднъж.
</p>
<p>	Ако направя клас променлива final, не мога да й направя сетър, няма нужда да имат setter - той няма да се компилира.
    Но мога да я инициализирам в конструктор. Защото конструктора се извиква само веднъж за
    всеки един обект, а сетъра би могъл да бъде извикан	много пъти от потребителя и това чупи дефиницията за Final.
</p>
<p>
    Final метод не може да се override-ва - така работи и точка. Функционалността му не може да се промени,
    измени или засенчи.
    Final клас не може да бъде наследяван. String е final клас.
</p>

<h4>STATIC</h4>
<p>
    <strong>static</strong> - статичното поле е поле, което е общо за всички обекти, генерирани по този клас.
    То е поле на класа, а не на някой от обектите от този клас. Статичното поле съществува, дори да няма създаден
    нито един обект и се достъпва чрез името на класа. Създадено е, за да спестява памет - една референция за всички
    обекти, вместо колкото обекти, толкова референции за това поле (един овчар за всички овце).
    <br />Когато се промени статичното поле, то става ново за всички обекти. Всички обекти имат достъп до тази референция.
    <br />Статичните полета се достъпват чрез името на класа, а не на обекта.
</p>
<p>
    <em><strong>Приложение: </strong>Когато много обекти имат една и съща стойност по определена характеристика -
        решението е static за тази характеристика.
        <br /> Най-често стотични полета и статични методи ще използвам, когато се чудя как да ги достъпя така, че
        да е по най-лесния начин.</em>
</p>
<p>
    Статична променлива не е променлива, която се заделя в паметта за всеки нов обект, а е една-единствена променлива,
    която е прикрепена към класа. Статик полетата са променливи на класа, а не променливи на обектите.
    <br />Статичен метод - той е метод на класа, а не на обекта. Той е развързан от обектите. По тази причина няма
    достъп до характеристиките на обектите, няма достъп до this. Викаме го през класа, а не през даден обект.
    <br />Статичен метод създаваме, когато е нужно да изпълним действия без да е нужно да създадем обекти (референции).
</p>
<p>
    <em>Приложение на static в практиката:</em>
    <br class = "indented" />public class item {
    <br style="margin-right: 75px"/>private static int uniqueId = 1;
    <br />private int itemId;
    <br />private String itemName;
    <br />
    <br />public Item(String itemName) {
    <br />this.itemName = itemName;
    <br />itemId = uniqueId;
    <br />uniqueId++;
    <br />}
    <br />}
</p>
<p>
    Задаваме статичен уникален номер, който е еднакъв за всички бъдещи генерирани обекти. При генериране поредния обект
    взима уникалния номер като свой и общия, уникален номер се инкрементира. Така пазим поредност.
</p>
<p>
    В клас променливите static + final дава константа. Тя задължително трябва да се инициализира при декларацията си
    в класа, защото е окончателна, непроменима променлива за целия клас и ще има една стойност за всички
    обекти, които бъдат създадени от този клас.
</p>

</body>
</html>