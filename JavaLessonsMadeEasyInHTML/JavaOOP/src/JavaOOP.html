<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JavaOOP</title>

</head>
<body>

<h1>Java OOP</h1>
<h2>Classes & Objects</h2>
<p>Когато създаваме класове и пишем методи в един клас, ние играем ролята на архитекти и пишем код, който ще се стартира, когато някой извика върху определен обект някакво действие.</p>
<p>Въпроси, които си задавам при създаването на един клас:</p>
<ol>
    <li><strong>Какво представлява?</strong> Как се казва? - ИМЕТО</li>
    <li><strong>Какво има?</strong>	- ХАРАКТЕРИСТИКИТЕ</li>
    <li><strong>Какво прави?</strong>	- МЕТОДИТЕ</li>
    <li><strong>Как се създава?</strong> Какво изисква, за да се създада? Без какво не може обекта от този клас?
        - КОНСТРУКТОРИ с какви параметри да създам</li>
</ol>
<p>Обект е всичко, което можем на наименоваме, дефинираме, покажем на някого - физически или абстрактни неща: вятърът,
    любовта, студът, бъдещето.
    Обектите представляват реална репрезентация на реални неща от реалния свят.
    Всеки обект има определено състояние (списък с х-ки) и определено поведение (действие, което може да извършва).
    Тези действия могат да променят състоянието на други обекти около него.
    STATE (какво има) and BEHAVIOUR (какво прави);
    Така програмата заприличва на симулация - огледало на реалния живот.</p>
<p>Класът е описание на нов референтен тип данни в Java.
    ОБЕКТЪТ Е ИНСТАНЦИЯ НА КЛАСА.
    Обектите са референтен тип данни, като типа на обекта е дефиниран в класа, от който е създаден.
    Обектът е стойност на променлива от тип Класа, от който е инстанциран. Можем да имаме променливи, които да сочат
    към тези обекти.
    <br /><strong>Car opel = new Car();</strong>
    <strong> opel</strong> е променлива в стека, която сочи към обекта в Heap-a (сбор от променливи и методи).
    Този обект е от тип <strong>Car</strong>.
    Класът описва характеристиките и поведението на обектите.</p>
<p>Променлива в класа представлява характеристика на всеки един от обектите, които ще бъдат създадени по образ и
    подобие на този клас.
   <br />Създаването на обекта не може да бъде прекратено. Каквото и да пиша в тялото на конструктора.
    Единствените варианти за това са да застрелям JVM със System.exit() - не се прави или да хвърля exception.

    <br />Когато искаме да достъпим характеристиките (елементите) на даден обект, взимаме референцията,
    която сочи към този обект и с точка достъпваме нейните характеристики.
    <br /><strong>Person ivan = new Person();</strong>
    <br /><strong>Person</strong> - име на класа;
    <br /><strong>ivan</strong> - референция към създадения с new обект от класа Person;
    <br /><strong>new.Person()</strong> - задели памет в хийпа и създай обект от тип Person с референция в стека ivan,
    която да сочи към него.
</p>
<p><strong> Когато дефинирам клас и се обръщам към нещо, за което знам, че е поле на класа, вътре в самия клас го адресирам
    с "this.". По този начин го отличавам от останалите променливи (към метод в класа и пр.).</strong>
</p>
<p><strong></strong>
    <strong>Getters & Setters</strong> са методи (някакъв интерфейс), който създателя на класа предоставя на външните
    ползватели за работа с полетата на класа, като е подсигурил, че няма да се наруши тяхната взаимовръзка от тази работа.
    <br /><strong>Getter</strong> 		- метод в клас, който връща някаква стойност от дадено поле на класа за генерирания обект;
    <br /><strong>Setter</strong> 		- метод в клас, който задава стойност на дадено поле на класа за генерирания обект;
    <br /><strong>Property</strong> 	- характеристика (променлива) в даден клас, заедно с нейния Getter и Setter.
</p>
<p>Класическа подредба при дефиниране на клас:
    <ul>
    <li>най-отгоре полета;</li>
    <li>след това конструктори;</li>
    <li>най-отдолу методи.</li>
    </ul>
</p>
<p>Състояние на един обект към даден момент от изпълнение на програмата са стойностите на неговите полета.</p>
<p>Ако дам println на променлива, сочеща към обект, ще получа типа на обекта + @ + hexadecimal на адреса на обекта.</p>

<h2>КОНСТРУКТОРИ:</h2>
<p>Имам default-ния конструктор по подразбиране. Ако създам конструктор с параметри, губя достъп до конструктора по
    подразбиране, докато не го създам (overload-на) изрично. Така, създавайки само конструктори с параметри
    мога да задължа потребителя да задава параметри на обектите при дефинирането им.</p>
<p><strong>Constructor overloading</strong> - дефинирането на повече от един конструктор в един клас с едно и също име,
    но с различни параметри.
    <strong>Constructor chaining</strong> - "навръзването" на конструктори (един конструктор вика друг, за да се
    избегне дублирането на код).
    Обикновено конструктор вика такъв с малко по-тесни функционалности и дописва допълненията.
    Constructor Chaining можем да имаме в рамките на класа или между класове в йерархична връзка (при наследяване -
    децата разширяват конструкторите на родителите си).
    Всички overload-нати конструктори трябва да се различават по брой, тип ИЛИ подредба на параметрите.</p>
<p>
    Чейнинга винаги е на първо място в коструктора. Не мога да добавя неща към нещо, което още не съм създал (в случая
    извикал от предходен конструктор). Викането на предходен конструктор изгражда обекта и описва характеристики, които
    вече съществуват в предходния конструктор. Едва след тях, можем да "допишем" допълнителни характеристики.
</p>
<p>
    Ключовата дума "this".
    <ul>
        <li>always refers to the current object, върху който се изпълнява действието;</li>
        <li>this (parameter1, parameter2) 	- използва се при Constructor chaining; Извиква съществуващ конструктор с
        посочените параметри и изпълнява тялото му в настоящия конструктор, за да не повтаряме код.</li>
        <li>в конструктора чрез this. достъпвам променливите на класа, за да избегна shadowing от променливи в параметрите
        на конструктора със същото име (this.name = name;). <br /> this.name е името на клас-променливата,
        name е името на променливата, подадена в конструктора. </li>
        <li>ако в характеристиките на класа подаваме клас от същия тип, напр. Person friend;, в конструктора мога да го
        извикам като  friend = this;, т.е. приятел е на самият себе си.</li>
        <li>не мога да подам нова стойност на this (this = null, например), защото this сочи само към текущия обект и няма
        как да започне да сочи към нищо друго.</li>
    </ul>
</p>
<p>
    Правила при конструкторите:
    <ul>
        <li>не мога да извикам два конструктора или един конструктор повече от веднъж в даден конструктор.</li>
        <li>извикването в конструктор на друг конструктор може да бъде само и единствено на първо място в тялото;</li>
    </ul>
</p>
<p>Мога да използвам setter в конструктора, когато покриват една и съща характеристика. Така няма да повтарям една
    и съща валидация на две места.</p>
<p>Метода може да върне само една стойност, вкл. и getter-а. Ако искам да върна две стойности, трябва да връщам
    тип Object[] - масив от обекти, защото всяко нещо е обект (наследяване и полиморфизъм).</p>

</body>
</html>