
15.12.2022 - преинсталиране изтри файлът с всичко дотук. Започвам отново от днес.



ПРОМЕНЛИВИ

Една променлива живее от момента, в който е декларирана до края на нейния блок от код.
	
ЛОГИЧЕСКИ ОПЕРАТОРИ

Съществува оптимизация, според която ако имам няколко операнда, свързани с логически "И" (&&) и първият е false, няма значение какви са останалите. Алгоритъмът няма да ги провери.
Ако имам няколко операнда, свързани с логически "ИЛИ" и първият е true, останалите няма да бъдат проверени (т.к. автоматично целият израз вече е true).

Тернарен оператор:


ЦИКЛИ

Вложените цикли винаги ги brake-вам с флагове. More maintainable. В бъдещ момент лесно може да се добави парче код в някой от циклите.
Avoid Label: // brake label; at all cost. Кодът се поддържа по-трудно и по-трудно може да се вмъкне допълнотелно парче, когато всичко се brake-ва наведнъж.



ARRAYS




METHODS

За да построя метод, трябва да си отговоря на 4 въпроса:
	- какво прави						-> name;
	- какво изисква, за да го направи 	-> parameters;
	- какво връща като резултат			-> return type;
	- как го прави						-> method body.

Когато пишем нов метод, в скобите дефинираме параметрите му (дефинираме променливите, които са му нужни за вход, за да работи). Дефинираме ги, но не ги инициализираме.
Променливите се инициализират наново всеки път, когато извикваме метода. Всеки път в тях СЕ КОПИРА стойността на подаваните аргументи, с които извикваме метода (наблюдаваме копиране по стойност).
	По тази причина НЕ мога да разменя стойността на две примитивни променливи от мейн метода с помощта на друг метод.
	По същата причина МОГА да разменя стойността на елементите на два масива (променливи от референтен тип) от мейн метода с помощта на друг метод (копира се стойността, т.е. адреса и двете променливи 
	пипат по един и същи масив, достъпен от две места).
	По същата причина Не мога да разменя стойността на два Стринга (референтни са, но са immutable). 

Мога да извикам скенер само веднъж в main метода:
	Scanner sc = new Scanner(System.in);
и да го преизползвам във всички методи, които пиша като го викам като параметър на всеки от тях.
	int number1 = readNumber(sc);
	int number2 = readNumber(sc);
	
static int readTwoDigitNumber(Scanner sc) {
	int n;
	do {
		System.out.print("Please, enter a 2-digit number: ");
		n = sc.nextInt();
	} while (n < 10 || n > 99);
	return n;
}

В ООП методът в един клас дефинира действия, които обектите, създадени от този клас биха правили. 

Constructor 	- специален вид метод (без return type) вътре в класа, който създава обект - инстанция на този клас;
 
 

STRINGS

Immutable array of chars.
String text1 = "Dilyan"; 				- checks StringPool and probably saves some memory.
String text2 = new String("Dilyan");	- ignores StringPool - прави се рядко, обикновено, когато се прави нов текст - резултат от друг текст.



String Methods:
	.charAt(int)				- връща символа, който се намира на посочения индекс;
	.equals()					- проверява дали стойността на двата символни низа съвпада;
	.equalsIgnoreCase()			- проверява дали стойностите са еднакви без оглед на това дали буквите са малки или големи;
	.compareTo()				- връща разликата в UniCode номерата на първите два различни символа в два стринга (ползва се при подреждане по азбучен ред);
	.split()					- разделя текст по посочен в скобите разделител. Начин да се преобразува текст в масив от стрингове (думи);
	.join()						- събира масив от стринг стойности в общ стринг, като ги разделя с посочения в скобите разделител;
	.substring(int)				- извлича от низа подниз, като започва от символа, намиращ се на позиция int до края на основния низ. Връща подниза като резултат;
	.substring(int1, int2)		- извлича от низа подниз, като започва от символа, намиращ се на позиция int1 до символа на позиция int2 - 1. Връща подниза като резултат;
	.replace(String1, String2)	- заменя всички срещания на подниз String1 в основния низ с подниз String2;
	.replaceAll("", "")			- example:
		String text = "My phone number is 0888111111 and yours is 0878222222."
		String censured = text.replaceAll("(08)[0-9]{8}", "***");	- замени с три звездички всичко в рамките на основния текст, което започва с "08" и съдържа 8 символа, всеки от които е от 0 до 9.
	//	"My phone number is *** and yours is ***."
		
	.trim()						- премахва интервалите в началото и в края на даден низ. Не приема аргументи;
	.strip()					- аналогично на .trim(), но............
	.indexOf(substring)			- връща като int първата позиция, на която даден subsring или char се среща в основния низ; Ако не се среща, връща стойност -1;
	.lastIndexOf()				- връща като int последната позиция, на която доден subsring или char се среща в основния низ; Ако не се среща, връща стойност -1;
	.toUpperCase()				- връща нов низ, в който всички букви от оригиналния са главни;
	.toLowerCase()				- връща нов низ, в който всички букви от оригиналния са малки;
	.contains(String)			- проверява дали даден низ се съдържа в друг. Връща boolean;
	.matches(regex:"")			- проверява дали текста съответства на подадения в скобите регулярен израз. Връща boolean.
	
String.format()					- ползваме го, за да конструираме нов символен низ по даден шаблон.	

StringBuilder	- 
	.insert()			- 
	.delete()			- 
	.replace()			- 
	.append()			- 
    
Get CHAR from STRING:
	String.valueOf(char)
	Character.toString(char)
	
Get INT from CHAR:	
	Character.getNumericValue(char) - връща цифрата зад символа.

RECURSION

Рекурсивен метод е метод, който вика сам себе си.	Рекурсия е явление, при което метод вика сам себе си.
За да работи, рекурсията има нужда от две характеристики:
	- стъпка	- извикване на същия метод с ДРУГ аргумент, който ВОДИ към дъното;
	- дъно		- специфична стойност на аргумента, при която извикания метод НЕ вика отново себе си.
	



LISTS

ArrayList = List = vector = dynamic array

	- СЪЗДАВАНЕ

List <Integer> nums = new ArrayList <> (Arrays.asList(10, 20, 30, 40, 50, 60));    - подаване на литерали в Списък

String values = sc.nextLine();
List<String> items = Arrays.stream(values.split(" ")).collect(Collectors.toList()); 	- конвертира стринга values в списък от стрингове

List<Integer> items = Arrays.stream(values.split(" ")).map(Integer::parseInt).collect(Collectors.toList());		- конвертира стринга values в списък от интове

	- ИЗВИКВАНЕ
products.get(i);


	- ПРЕМАХВАНЕ

nums.remove(2); 	- премахва втория елемент в списъка (по индекс - 2);
nums.remove(Integer.valueOf(30)); 	- премахва елементът със стойност 30;

names.remove("Maria");	- премахва елемента "Maria" от списък със String-ове.


	- ДОБАВЯНЕ

nums.add(100); 		- добавя числото 100 на края на нашия списък
nums.add(0, -100);	- добавя числото -100 на позиця (индекс) 0 (нула)


	- ПРИНТИРАНЕ

for (int i = 0; i < nums.size(); i++);
System.out.print(nums.get(i) + " ");

for (int index = 0; index < list.size(); index++)
  System.out.printf("arr[%d] = %s%n", index, list.get(index));
  
System.out.println(String.join("; ", list));		- принтира само листове от стрингове; 


	- ПРОВЕРКА

names.contains("Maria")	- проверява дали елементът "Maria" е наличен в нашият списък. Връща boolean
nums.contains(10)	- проверява дали списъка съдържа числото 10. Връща boolean
sout(nums.contains(10)); - принтира true/false;
names.isEmpty(); - връща true/false според това дали списъка е празен или не. Връща boolean
nums.size(); - връща дължината на списъка


	- ЗАМЯНА

names.set(index, item)	- заменя елемента да дадения индекс

	- СОРТИРАНЕ

Collections.sort(names);
Collections.reverse(nums);






АЛГОРИТЪМ 	- последователността от стъпки, която трябва да се предприеме, за да се реши някоя задача.

Ефикасността на един алгоритъм зависи от неговата сложност (efficiency depends on complexity);
При избор на алгоритъм трябва да оценя сложността му и да си дам сметка в какъв процент от случаите с какви данни работя. 
СЛОЖНОСТ НА АЛГОРИТЪМ представлява как се изменят определени параметри при изменение на входните данни на проблема. Сложността е два вида:
	- СЛОЖНОСТ ПО ВРЕМЕ - колко е бърз един алгоритъм (КАК СЕ ИЗМЕНЯ ВРЕМЕТО НА АЛГОРИТЪМА ПРИ ПРОМЯНА НА ВХОДНИТЕ ДАННИ) 	- натоварва процесорното време (брой операции).
	- СЛОЖНОСТ ПО ПАМЕТ - колко памет заема един алгоритъм (КАК СЕ ИЗМЕНЯ ЗАЕТАТА ПАМЕТ НА АЛГОРИТЪМА ПРИ ПРОМЯНА НА ВХОДНИТЕ ДАННИ) - натоварва разполагаемата памет.
	
Алгоритъм се означава с O (N), като в скобите се поставя функция на сложността на алгоритъма от входните данни (в случая - линейна сложност).
	
	
Popular COMPLEXITY for input of size N

NUMBER OF OPERATIONS		Big O			SHORT NAME
1, 5, 10, 10 000			O(1)			constant complexity
logN, logN + 10				O(logN)			logarithmic
N, 2*N, 10*N+5				O(N)			linear	
N*logN, N*log2*N			O(N*logN)		linearithmic
N^2, 3*N^2+N+1				O(N^2)			quadratic
N^3, N^3+N^2				O(N^3)			cubic
N^K; K - constant			O(N^K)			polynomial
2^N, 3^N, 2^N + N^2			O(2^N)			exponential
N!							O(N!)			factorial
	
	
	
	
Най-бързият алгоритъм за търсене в числова редица е с логаритмична сложност.
Най-бързият алгоритъм за сортиране е с линеаритмична сложност (линейна х логаритмична).
Квадратичните алгоритни все още се считат за относително бързи.

Complexity in the:
	- best case		- при най-благоприятните входни данни;
	- average case	- средностатистически за всички сценарии на входни данни;
	- worst case	- при най-неблагоприятните входни данни;
	
BUBBLE SORT - МЕТОД НА МЕХУРЧЕТО
В общия случай това е метод с квадратична сложност.
В най-добрия случай (при почти подредени масиви данни) е с линейна сложност (само след оптимизация с флаг, но тогава е екстремно бързо).
Работи добре при малки масиви и зле при големи масиви.

SELECTION SORT - СОРТИРАНЕ ПО МЕТОДА НА ПРЯКАТА СЕЛЕКЦИЯ
Също с квадратична сложност, но при оптимизиране има двойно по-малко операции от bubble sort в общия случай.
Работи добре при малки масиви и зле при големи масиви.

COUNTING SORT
Работи добре с всякакви по размер масиви, СТИГА ДИАПАЗОНА НА ЧИСЛАТА ИМ ДА Е МАЛЪК.

RADIX SORT
Radix Sort e алгоритъм, който комбинира няколко Counting Sort-а (по един за цифрите на единиците, за цифрата на десетиците, за цифрата на стотиците, ....).
Той работи с линеаритмична сложност (линейна * логаритъм от 10).
Radix sort е сред най-бързите масиви за сортиране по време, но не е най-бърз по памет, защото има нужда от допълнителен масив за сортиране. QUICK SORT е също толкова бърз по време, но е по-бърз по памет, 
защото работи директно с основния масив от данни.




QUICK SORT
Най-добрата възможна стойност за pivot (отправно число) е медианата на множеството (Me).



