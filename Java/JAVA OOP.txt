C L A S S E S  &  O B J E C T S :


Когато създаваме класове и пишем методи в един клас, ние играем ролята на архитекти и пишем код, който ще се стартира, когато някой извика върху определен обект някакво действие.

Въпроси, които си задавам при създаването на един клас:
	1. Какво представлява? Как се казва? - ИМЕТО
	2. Какво има?	- ХАРАКТЕРИСТИКИТЕ
	3. Какво прави?	- МЕТОДИТЕ
	4. Как се създава? Какво изисква, за да се създада? Без какво не може обекта от този клас? 	- КОНСТРУКТОРИ с какви параметри да създам;

Обект е всичко, което можем на наименоваме, дефинираме, покажем на някого - физически или абстрактни неща: вятърът, любовта, студът, бъдещето.
Обектите представляват реална репрезентация на реални неща от реалния свят.
Всеки обект има определено състояние (списък с х-ки) и определено поведение (действие, което може да извършва). Тези действия могат да променят състоянието на други обекти около него.
STATE (какво има) and BEHAVIOUR (какво прави);
Така програмата заприличва на симулация - огледало на реалния живот.

Класът е описание на нов референтен тип данни в Java.
ОБЕКТЪТ Е ИНСТАНЦИЯ НА КЛАСА.
Обектите са референтен тип данни, като типа на обекта е дефиниран в класа, от който е създаден. Обектът е стойност на променлива от тип Класа, от който е инстанциран. Можем да имаме променливи,
които да сочат към тези обекти.
Car opel = new Car();
opel е променлива в стека, която сочи към обекта в Heap-a (сбор от променливи и методи). Този обект е от тип Car.
Класът описва характеристиките и поведението на обектите.

Променлива в класа представлява характеристика на всеки един от обектите, които ще бъдат създадени по образ и подобие на този клас.

Създаването на обекта не може да бъде прекратено. Каквото и да пиша в тялото на конструктора. Единствените варианти за това са да застрелям JVM със System.exit() - не се прави или да хвърля exception.

Когато искаме да достъпим характеристиките (елементите) на даден обект, взимаме референцията, която сочи към този обект и с точка достъпваме нейните характеристики.
Person ivan = new Person();
Person - име на класа;
ivan - референция към създадения с new обект от класа Person;
new.Person() - задели памет в хийпа и създай обект от тип Person с референция в стека ivan, която да сочи към него.

! Когато дефинирам клас и се обръщам към нещо, за което знам, че е поле на класа, вътре в самия клас го адресирам с "this.". По този начин го отличавам от останалите променливи (към метод в класа и пр.).
Getters & Setters са методи (някакъв интерфейс), който създателя на класа предоставя на външните ползватели за работа с полетата на класа, като е подсигурил, че няма да се наруши тяхната взаимовръзка от тази работа.
Getter 		- метод в клас, който връща някаква стойност от дадено поле на класа за генерирания обект;
Setter 		- метод в клас, който задава стойност на дадено поле на класа за генерирания обект;
Property 	- характеристика (променлива) в даден клас, заедно с нейния Getter и Setter.

Класическа подредба при дефиниране на клас:
	- най-отгоре полета;
	- след това конструктори;
	- най-отдолу методи.

Състояние на един обект към даден момент от изпълнение на програмата са стойностите на неговите полета.

Ако дам println на променлива, сочеща към обект, ще получа типа на обекта + @ + hexadecimal на адреса на обекта.

КОНСТРУКТОРИ:

Имам default-ния конструктор по подразбиране. Ако създам конструктор с параметри, губя достъп до конструктора по подразбиране, докато не го създам (overload-на) изрично. Така, създавайки само конструктори с параметри
мога да задължа потребителя да задава параметри на обектите при дефинирането им.

Constructor overloading - дефинирането на повече от един конструктор в един клас с едно и също име, но с различни параметри.
Constructor chaining - "навръзването" на конструктори (един конструктор вика друг, за да се избегне дублирането на код). Обикновено конструктор вика такъв с малко по-тесни функционалности и дописва допълненията.
Constructor Chaining можем да имаме в рамките на класа или между класове в йерархична връзка (при наследяване - децата разширяват конструкторите на родителите си).
Всички overload-нати конструктори трябва да се различават по брой, тип ИЛИ подредба на параметрите.

Чейнинга винаги е на първо място в коструктора. Не мога да добавя неща към нещо, което още не съм създал (в случая извикал от предходен конструктор). Викането на предходен конструктор изгражда обекта и описва
характеристики, които вече съществуват в предходния конструктор. Едва след тях, можем да "допишем" допълнителни характеристики.

Ключовата дума "this".
	- always refers to the current object, върху който се изпълнява действието;
	- this (parameter1, parameter2) 	- използва се при Constructor chaining; Извиква съществуващ конструктор с посочените параметри и изпълнява тялото му в настоящия конструктор, за да не повтаряме код.
	- в конструктора чрез this. достъпвам променливите на класа, за да избегна shadowing от променливи в параметрите на конструктора със същото име (this.name = name;).
	this.name е името на клас-променливата, name е името на променливата, подадена в конструктора.
	- ако в характеристиките на класа подаваме клас от същия тип, напр. Person friend;, в конструктора мога да го извикам като  friend = this;, т.е. приятел е на самият себе си.
	- не мога да подам нова стойност на this (this = null, например), защото this сочи само към текущия обект и няма как да започне да сочи към нищо друго.

Правила при конструкторите:
	- не мога да извикам два конструктора или един конструктор повече от веднъж в даден конструктор.
	- извикването в конструктор на друг конструктор може да бъде само и единствено на първо място в тялото;

Мога да използвам setter в конструктора, когато покриват една и съща характеристика. Така няма да повтарям една и съща валидация на две места.

Метода може да върне само една стойност, вкл. и getter-а. Ако искам да върна две стойности, трябва да връщам тип Object[] - масив от обекти, защото всяко нещо е обект (наследяване и полиморфизъм).


Ч Е Т И Р И Т Е   П Р И Н Ц И П А   Н А   О О П :

КАПСУЛАЦИЯ 		-	ENCAPSULATION
НАСЛЕДЯВАНЕ		-	INHERITANCE
АБСТРАКЦИЯ		-	ABSTRACTION
ПОЛИМОРФИЗЪМ	-	PLYMORPHISM


К А П С У Л А Ц И Я :	

Модификатори за достъп - инструментите, чрез които реализираме капсулацията. Те са ключови думи, които слагаме в декларацията на конструктор, метод, променлива или клас: (public, private, default, protected);
	- private 	- ключова дума, която описва, че до полето след нея достъп ще има само самия клас, в който то се намира. Ползват го само методи и конструктори на класа и никой извън класа няма достъп до него.
	- default 	- не е ключова дума. Просто не се пише нищо пред полето. Дефолтният модификатор указва, че до полето имат достъп текущият клас и всички други класове в текущия пакет.
	- protected	- защитените полета и методи са видими в рамките на класа, в рамките на текущия пакет и за децата на класа (независимо в коя папка се намират те);
	- public 	- поставя се пред поле и го прави публично (достъпно от целия проект, независимо в какъв пакет се намираме).
Добра практика: всичко е private, докато някой не проплаче, че му трябва достъп. Като направя всички характеристики private, веднага лъсват security breaches, където някой е направил пряк достъп до променлива.
Защото прекия достъп до променлива е неконтролиран достъп, който не мога по никакъв начин да валидирам. Avoid at all cost!
Класовете могат да бъдат само public или default.
Всички останали модификатори за достъп мога да поставя на характеристика, на конструктор, на методи.

	- FINAL - ключова дума. Поставя се пред променлива, която веднъж инициализирана, до края на живота си (в блока код) не трябва да променя стойността си и обратното би било пагубно за логиката.
	Final променлива - променлива, която веднъж инициализирана, повече не може да променя стойността си.
	Мога ли на final референтна променлива да пипам характеристиките? Мога. Но не мога да подменя адреса, не мога да я накарам да сочи към друго място, друг адрес, друга променлива.
	Final клас променлива може да се инициализира или още при декларация (но тогава стойноста й е предварително зададена за всички бъдещи обекти), или в конструктор, защото той се изпълнява само веднъж.
	Разбира се, не може и при двете - това би довело до повторна инициализация.
	Final променливата задължително трябва да бъде инициализирана. Веднъж.

	Ако направя клас променлива final, не мога да й направя сетър, няма нужда да имат setter - той няма да се компилира. Но мога да я инициализирам в конструктор. Защото конструктора се извиква само веднъж за
	всеки един обект, а сетъра би могъл да бъде извикан	много пъти от потребителя и това чупи дефиницията за Final.

	Final метод не може да се override-ва - така работи и точка. Функционалността му не може да се промени, измени или засенчи.
	Final клас не може да бъде наследяван. String е final клас.

	- STATIC - статичното поле е поле, което е общо за всички обекти, генерирани по този клас. То е поле на класа, а не на някой от обектите от този клас. Статичното поле съществува, дори да няма създаден
	нито един обект и се достъпва чрез името на класа. Създадено е, за да спестява памет - една референция за всички обекти, вместо колкото обекти, толкова референции за това поле (един овчар за всички овце).
	Когато се промени статичното поле, то става ново за всички обекти. Всички обекти имат достъп до тази референция.
	Статичните полета се достъпват чрез името на класа, а не на обекта.

	Приложение: Когато много обекти имат една и съща стойност по определена характеристика - решението е static за тази характеристика.
				Най-често стотични полета и статични методи ще използвам, когато се чудя как да ги достъпя така, че да е по най-лесния начин.

	Статична променлива не е променлива, която се заделя в паметта за всеки нов обект, а е една-единствена променлива, която е прикрепена към класа. Статик полетата са променливи на класа, а не променливи на обектите.
	Статичен метод - той е метод на класа, а не на обекта. Той е развързан от обектите. По тази причина няма достъп до характеристиките на обектите, няма достъп до this. Викаме го през класа, а не през даден обект.
	Статичен метод създаваме, когато е нужно да изпълним действия без да е нужно да създадем обекти (референции).

Приложение на static в практиката:
	public class item {
		private static int uniqueId = 1;
		private int itemId;
		private String itemName;

		public Item(String itemName) {
			this.itemName = itemName;
			itemId = uniqueId;
			uniqueId++;
		}
	}
Задаваме статичен уникален номер, който е еднакъв за всички бъдещи генерирани обекти. При генериране поредния обект взима уникалния номер като свой и общия, уникален номер се инкрементира. Така пазим поредност.

В клас променливите static + final дава константа. Тя задължително трябва да се инициализира при декларацията си в класа, защото е окончателна, непроменима променлива за целия клас и ще има една стойност за всички
обкети, които бъдет създадени от този клас.

Н А С Л Е Д Я В А Н Е :
 
Наследяването става чрез ключовата дума "extends" и се описва в декларацията на класа:
public class Cat extends Animal;

Each class can extend only one class.

RightClick on Project / Diagams / Show Diagram - показва дървовидната структура на класовете в проекта.
Дървото на класовата йерархия има:
	- корен - клас, който няма родител;
	- възли - всеки клас между корена и листата; може да бъде родител на много деца или дете на друг родител;
	- листа	- деца, които не биват наследени.

Subclass Constructors	-
	Всеки клас при конструирането на обект първо извиква суперконструктора на класа-родител. Това се случва автоматично при дефолтни конструктори.
	При липса на дефолтен конструктор в класа-родител, в класа дете трябва да извикам ръчно конструктора на класа-родител, който избирам да се използва при създаване на референция на детето.
	Това се прави с ключовата дума "super". Тя е аналогична на ключовата дума "this", но се отнася не за референцията на настоящия клас, а за референцията на родителския клас.
	Invocation of a superclass constructor must be the first line in the subclass constructor. Всеки конструктор на първия си ред ТРЯБВА да извика суперконструктор.

Кострукторите в класовете имат роля да заделят памет в хийпа за характеристиките на класа.
За да създам тигър, трябва да заделя памет за характеристиките на тигъра, тези на котката и тези на животното. Т.е. трябва да извикам три конструктора индиректно, за да може тигърът да има достъп до всички тези х-ки.

METHOD OVEERIDING - предефиниране на наследен метод
Имаме действие (метод), което сме наследили от суперкласа, но решаваме, че то не работи добре от субкласа, затова го предефинираме в субкласа и така шадоулваме този отгоре.
За целта трябва да напиша 1:1 декларацията на метода със същата сигнатура.
method signature -> (return type) + name + parameters /number + type + order/;
При override-ване, return type-а на субметода може да бъде или същия тип като override-натия суперметод, или подтип на горния (нарича се КОВАРИАНТНОСТ или ковариентен return type).
Когато в някоя референция се ивика метод, се търси най-близката дефиниция на този метод в класовата йерархия и се вика тя (overriding + shadowing).

В един клас не можем да имаме два метода с една и съща сигнатура.
В един клас не можем да имаме два конструктора с една и съща сигнатура.

Ключовата дума this  се използва за достъп до (характеристика, действие) в настоящия клас.
Ключовата дума super се използва за достъп до (характеристика, действие) в горния parent клас.
Не мога да прескоча ниво. Мога да извикам само нещо от горното ниво. Но в него също мога да извикам характеристика или метод със super и така да предам нагоре.
Това е важно, когато искам да допълня определена функционалност при детето.

При Method overriding, метода на суперкласа няма нужда да се извиква на първо място и може да бъде извикан (или не) повече от веднъж. За разлика от invocatiom of superclass constructor.

При method overriding можем да разширяваме или запазваме достъпа, но не можем да го свиваме (ограничаваме).
Ако метода в суперкласа е public, в субкласа също трябва да е public.
Ако метода в суперкласа е protected, в субкласа трябва да е protected или public.
Ако метода в суперкласа е default, в субкласа трябва да е default, protected или public.
Ако метода в суперкласа е private, в субкласа този метод се наследява, но не може да бъде override-нат, защото детето няма достъп до private на родителя - наследява го без достъп (по дефиниция
се вижда само в рамките на класа, в който е дефиниран).


A B S T R A C T I O N :

Абстракция можем да реализираме чрез интерфейс или чрез абстрактен клас.
Чрез абстрактното понятие мога да работя с дефиниция за група, без да ме интересува с коя и каква точно част от групата работя в конкретния момент.

"ИНТЕРФЕЙС" е структура в Java - също като класът: всичко, което мога да правя с конкретно нещо - сборът от функционалности, които ми се предоставят като потребител.
ИНТЕРФЕЙСЪТ Е АБСТРАКТНА СТРУКТУРА, КОЯТО ОПИСВА  С А М О  ПУБЛИЧНИ ФУНКЦИОНАЛНОСТИ.
Мога да дефинирам общото понятие за обект като само опиша неговите функционалности и му дам име. После мога да създам други обекти, които (ако искат да се наричат така) задължително трябва да имат тези функционалности.
КОГА ЩЕ ПОЛЗВАМ ИНТЕРФЕЙС? 
	- Когато искам да групирам определено количество класове - да бъдат под общ знаменател 
	- Когато искам да им вменя общи функционалности, да се наричат по общ начин.
При интерфейсите, мога да имплементирам в един клас няколко интерфейса (implement) и този клас да е част от няколко групи. Това прави интерфейсите толкова мощни.
При наследяването, всеки клас може да наследи (extend) само един клас и това е ограничаващо.
Интерфейсите са начини, по които можем да групираме обекти и да им вменяваме (да ги задължаваме да имат) определена функционалност.

Основни плюсове на интерфейсите: можем да дефинираме групи. Задължаваме тези групи да имат определена функционалност: Дефинираме тип данни. Казваме на класовете, че имплементират този тип данни и си правя
масив от този тип данни. Тогава в масива могат да влязат САМО обекти, чиито класове са имплементирали интерфейса.
Другояче казано: Събираме всички обекти от тези групи под общ знаменател и можем да ги вкарваме в масив, където само те могат да бъдат, а никой друг - не може.

Интерфейсите се наименоват като нещо, което може да извършва някакво действие. Или като нещо, върху което може да се извършва някакво действие.
Например, завършващи на ABLE или започващи с I. // вместо ЕxplodingDevice -> ExplodableX или например IBomb.
Това не е задължително, но е добра практика и веднага някой от името ще се сети, че това е интерфейс.

Интерфейса създава нов тип данни, т.е. можем да имаме референция от тип интерфейс.
Интерфейса може да съдържа само методи, които АБСОЛЮТНО ЗАДЪЛЖИТЕЛНО са public (дори да не сме упоменали ключовата дума при дефинирането на метода).

В интерфейса можем да имаме променливи, но те трябва да са инициализирани, защото задължително са public static final.
int x;		- не се компилира в интерфейса
int X = 5;	- се компилира като public static final;
т.е. в интерфейса не можем да имаме променливи, а само КОНСТАНТИ.
КОНСТАНТИТЕ се именуват с главни букви и с долни черти. Например: MAX_RANGE

Добра практика е да се правят много интерфейси с малко методи всеки, за да мога да правя гъвкави комбинации, които да групират различните функционалности.
Когато един parent клас имплементира интерфейс, той трябва да override-не методите на интерфейса. Децата му също ще имат тези методи. Те могат да ги override-нат, но не са задължени, защото този метод вече има
реализация в тялото на родителя.

В класовете, които имплементират даден интерфейс ТРЯБВА да override-на методите на интерфейса (да ги реализирам с тела). Всички методи на интерфейса са public (независимо дали ще го изпиша или не), НО
в класовете трябва да упомена методите като public, защото ако не ги упомена, ще са по подразбиране default, а при override-ване мога само да разширявам или запазвам обхвата, но не да го стеснявам.
Затова, когато дефинирам метод в интерфейс, мога да ползвам само public или default (празен) идентификатора (пак ще го приеме за public). Не мога да ползвам protected или private.

Marker Interface - интерфейс, който няма методи и се ползва само за групиране на обекти.

Интерфейса вменява само функционалности, не вменява характеристики. Например "Врата" не е подходящо име за интерфейс, защото предполага характеристики (размер, цвят, материал). Интерфейс е "Отварящо средство".
Този интерфейс може да бъде имплементиран както от клас Врата, така от клас Прозорец и от клас Чекмедже.
Клас, който имплементира интерфейс, трябва да имплементира ВСИЧКИ методи от интерфейса. Няма да се компилира, ако пропусна някой. Или класът трябва да бъде деклариран като абстрактен.

АБСТРАКТЕН КЛАС:

Обикновено бих предпочел абстрактен клас пред интерфейс. Той има почти всички плюсове на интерфейса, но за разлика от него има и клас полета, има конструктори, обикновени, protected и всякакви методи.
Ще предпочета интерфейс, когато искам да не ограничавам обектите.
Също като при интерфейса, от абстрактния клас не могат да се правят обекти. Но в абстрактния клас всичко може да е private, освен абстрактния метод (абстрактните методи) в него. Защото би противоречало на логиката.

Ако в един клас имам абстрактен метод, то класът със сигурност трябва да е абстрактен, НО мога да имам абстрактни класове, които не съдържат абстрактни методи. Така просто забранявам създаването на обекти от тях.
Предимството интерфейс пред абстрактен клас са множеството наследявания. И това е единствения случай, в който ще предпочета интерфейс пред абстрактен клас.

Pure Abstract Class - клас, на който всичките му методи са абстрактни.
	ПЛЮС: 	За разлика от интерфейса, в него мога да имам полета, които да бъдат наследени и др.
	МИНУС: 	За разлика от интерфейса - един подклас наследи ли го - край! Подкласът повече не може да наследи нищо друго.
Затова винаги избирам Интерфейс пред Чист Абстрактен Клас.

Ако нямам нужда от полета, винаги предпочитам да направя интерфейс, защото той не ограничава обектите. Подкласовете, които го имплементират, все още могат да наследят или имплементират още нещо.

Абстрактен клас се ползва:
	- когато не искам от даден клас да се правят обекти;
	- когато искам да вкарам функционалност, която не мога да опиша в този клас и така задължавам децата да я реализират;
	- когато имплементирам интерфейс, но в този клас все още не съм сигурен как да се държат методите на интерфейса.
Абстрактният клас може да съдържа абстрактни методи, но може и да не съдържа. Ако не съдържа, това е просто клас, от който не мога да правя обекти. Но клас, който съдържа абстрактен метод, ЗАДЪЛЖИТЕЛНО трябва
да е абстрактен.

! Когато наследя абстрактен клас, трябва задължително да имплементирам всички негови абстрактни методи или ако не мога (все още не знам как) аз също трябва да стана абстрактен клас и да предам тази отговорност на
своите деца. Ще override-на метод в абстрактен клас само ако зная, че той е валиден за всички от това множество.
Пример абстрактен клас Бозайник наследява обстрактен клас Животно и от него наследява метода makeNoise(); В бозайник мога да го override-на, за да мяука, ако съм сигурен, че всички бозайници мяукат:
котки, кучета, мишки, скунксове... В противен случай ще оставя метода абстрактен и така ще предам задължението на децата на Бозайник да го override-нат със специфичния за всеки клас животно звук:
котка- мяу; куче - бау.

	ОБОБЩЕНИЕ: Ако нямам нужда от полета, винаги предпочитам интерфейсите, защото те не ограничават обектите.
Всъщност интерфейсът е структура, в която има САМО абстрактни методи и константи.

Абстрактен клас И интерфейс.
	Прилики:
		- и от двата НЕ могат да се създават обекти;
		- и в двете структури мога да имам абстрактен метод;
		- наследниците и на двете са ЗАДЪЛЖЕНИ да имплементират тези абстрактни методи ИЛИ на свой ред са бъдат обявени за абстрактни структури.
		- и двете структури се ползват за реализиране на абстракция.
	Разлики:
		- абстрактния клас може да съдържа полета, интерфейсът не - само константи.
		- абстрактния клас има конструктори, интерфейсът - не.
		- в абстрактния клас мога да имам default, protected и private методи; В интерфейса мога да имам само public методи (и default методи с тяло само от Java8, насетне. Тези методи важат за всички подинстанции).
		(в абстрактния клас мога да имам методи с тяло, в интерфейса - не (мога, но само с ключовата дума default и само от Java 8, нататък)
		- абстрактния клас може да бъде наследен и един клас може да наследи само един абстрактен клас, но може да наследи множество интерфейси.
Абстрактните методи в абстрактните класове изискват ключовата дума abstract при декларирането на метода. Абстрактните методи в интерфейсите просто се декларират с име.

Добрата практика е един програмист ВИНАГИ да се старае да работи с абстракции, а не с конкретики. За да може при изчезване на класове или поява на нови да не се пренаписва код, а зависимостите да остават валидни.

Ако няколко неща ми се различават по един признак и съм в дилема дали на направя един клас с няколко характеристики, които да суичвам или няколко класа, които да овъррайдват същия метод... наследяването е
по-extensible варианта. Защото ако добавя характеристика (оръжие, тип същество), класът ми със суичовете ще избухне в размер (ще стане God class), а това е лоша практика. С наследяването няма да спестя код, но в
дългосрочен план ще спестя време за редакции, нерви, код, грешки.


П О Л И М О Р Ф И З Ъ М :

Една променлива има свойството да приема различни форми (да се държи по различен начин) в различен контекст.
	Златно правило:
		- Method invocation depends on reference type - кой метод мога да извикам върху дадена променлива зависи от типът на тази променлива (типът на променливата определя достъпът до методите - всички, дефинирани
		в класът на променливата или по-нагоре в йерархията);
		- Method execution depends on instance type - кой метод точно ще се изпълни (кое тяло) зависи от типа на инстанцията (на обекта), към който тази референция сочи. Това идва от override-ването (търси се най-
		близката реализация на класа, тръгвайки от текущия нагоре по йерархията)

Мога при обхождането на обектите с референция от перънт клас да кастна обекта към някое от конкретните деца, което ми трябва, НО САМО СЛЕД ПРОВЕРКА. В противен случай ще ми хвърли ексепшън.
Това е downcasting - да се опитаме да намачкаме референция към такава, която е неин подтип.
ClassCastExeption		- ексепшън, когато се опитвам да намачкам перънт клас към клас конкретно дете, но референцията в момента сочи към друго дете на същия перънт.
instance of		/референция instance of тип данни/ - булев израз, връща true или false дали референцията е от посочения тип данни или негово дете.

Ако си забраня (сам) да ползвам instance of, сам ще се задължа да имам добра абстракция.
Добрата абстракция е тази, която не зависи от наличието (или липсата) на конкретен клас. Например ако кастна и проверя с instance of, ща завися от класа, който съм проверил и към който съм кастнал (трябва да е
наличен, за да не си счупя кода, ако някой го махне).


Upcasting - като цяло в общата практика е пълна глупост. При upcasting губя специфичните методи за моя клас, губя характеристиките му и получавам само тези на родителя, към който съм upcast-нал.
НО има един специфичен случай, когато е полезно:
psvm {
Cat pisi = new Cat();
pet(pisi)   / * pet(Animal a)			- предлага ми да извика някой от двата метода, но по подразбиране вика по-специфичния.
			/ * pet(Cat cat)

}
static void pet(Animal a) {
	a.makeNoise();
}
static void pet(Cat cat) {
	cat.purr();
}

Ако parent класа има действие Animal.makenoise() и субкласа го наследява, но има Methos overloading - извиквам метода с различни параметри (веднъж с animal и веднъж с cat).
Тогава ще мога да извикам pet() върху Cat. И двата метода ще са валидни,  но JAVA ще използва по-специфичния и при Cat.pet(); котката ще измърка, а няма да издаде звук както би направило всяко животно.
АКО все пак искам котката да измяука при погалване, ще трябва да upcast-на:


final method() - с ключова дума final, методът не може да се override-ва.
final class - с ключова дума final пред класа, класът не може да бъде наследяван.


E N U M :

Тип данни, от който можем да създаваме константи. Служат за ограничение, валидация.
Създава се както клас и интерфейс.
Елегантен начин да задължим в метод да се подават краен брой и точно конкретни, предварително дефинирани като константни в Enum-а стойности.

Enum-ите групират константи под общ тип. И понеже това е тип данни, можем да имаме референция към него.

Пример:
public class Cage {
	public void putPrisoner(Prisoner p){
		System.out.println("You put " + p + " in jail.");
	}
}*

public enum Prisoner {
	KILLER, RAPIST, THIEF, SMUGGLER;
}

Public class Demo {
	psvm {
		Cage cage = new Cage();
		cage.putPrisoner(Prisoner.SMUGGLER);		- тук, при референцията от тип Prisoner мога да подам само една от дефинираните по-горе константи. Върши чудесна работа, за да не ми напише някой произволен вход.
	}
}


J A V A   G E N E R I C S :


Cage <A>	- генеричен тип. Типа данни ще се генерира в момента, в който създам обекта от тип Cage.
			Когато не е дефиниран изрично типа <A>, демото връща клетка от тип Object и в клетката мога да вкарам всякакъв тип обекти.
			За да не влезе произволен обект, при извикването на класа и създаването на обекта, пиша:
			Cage<Cat> cage = new Cage(); 	- по този начин мога да слагам вътре само котки. След това - каквото съм поставел в <> при генерирането на следващия обект от тип Cage.
			
Common type Parameters in Java Generics:
T – Type
E – Element
K – Key
N – Number
V – Value


В Л О Ж Е Н И   К Л А С О В Е :

Вложени класове се правят по няколко причини:
	- спестяваме файл за тях;
	- можем да го дефинираме като private class;

Влажените класове могат да бъдат static или inner:

STATIC вложен клас:
 - Логическа обвързаност - ако един клас работи с обекти, които имат значение САМО за него и се знае, че така или иначе НИКОЙ друг клас няма да ги ползва, ги инстанцираме от негов вложен клас, защото 
така мога да спестя текстовите файлове за всеки отделен клас.
 - Increased Encapsulation - когато няма нужда останалите да научават за съществуването на тези обекти (increased encapsulation - не само да не могат да се правят обекти, въобще никой да не знае 
за съществуването на този клас);
 - Когато искаме тези класове да достъпват private статични полета на друг клас. Вътрешните статични класове имат пряк достъп до статичните полета на вършния клас (дори те да са private). 
Друг вариант е полетата на основния клас да са default, вместо private и двата класа да са сами в своя папка.

Правим вложени статични класове, когато искаме тази класове да достъпят PRIVATE статични полета и когато искаме да си спестим текстовия файл.

INNER class:
Понякога имаме нужда да създаваме класове само, обвързани със съществуването на други класове. Така симулираме органи в тялото, симбиоти, паразити и пр.
Вътрешния клас зависи от живота на обекта от външния клас. Той може да бъде създаден към ОБЕКТ от външния клас (хост). Без обект от хоста, не можем да създадем обект от вътрешния клас (class Person && class Brain).
Обектът от вътрешния клас може да живее само докато хоста му живее, но той има пълен контрол до своя хост (директен достъп до характеристики, достъп до методи, всичко).
САМО през инстанцията на обкръжаващия клас мога да създам обект от вътрешния. Няма нужда от капсулация, от референция към моя човек. Мозъка си знае човека - към него е създаден.
През мозъка мога да променям характеристиките на Човека (обекта от външния клас).

 Person dido = new Person();
 Brain naDidoMozuka = dido.new Brain();
 
 naDidoMozuka.changeName("Kiro");	- при дефиниран changeName() метод в вътрешния клас (мозъка), мога в Demo-то да кажа на мозъка на смени името на обекта, към който е прикрепен (на Дидо);

 Вложения клас има достъп до пропъртитата на външния, но външния няма достъп до пропъртитата на вътрешния (освен ако не го направи през референцията)

public Person() {
	this.brain = new Brain();
}
Т.к. new Brain съм го създал в конструктора на Person, той автоматично се прикрепя към новосъздадения от този конструктор обект от тип Person.


NESTED CLASS	-> class, defined in another class;

class Outer {
	class Nested {

	}
}

	WHY?
		->	no need for text file .java;
		->	can be private -> hide it from any other class, anywhere in the project;

	2 types nested classes:
		->	static nested
			->	keyword static upon declaration;
			->	instances can exist independently from any other;
		->	non-static (inner) class:
			->	declaration without static keyword;
			-> 	instances are attached, linkedand bound to an instance of the outer class;

	WHEN use them?
		-> we do not want to mess the project with additional files that are used once or twice (static);
		-> we do not want to create instances that are independent (brain from human)

LOCAL CLASS - did you know? :)
	->	Class, defined in a block of code:
		-> you can create variables and instances inly in this block of code;

NESTED INTERFACE
Прави се само, за да се спести допълнителен файл. Обикновено за Marker interface.
Вътрешните интерфейси могат да бъдат само статични (защото от интерфейс така или иначе не могат да се създават инстанции).


А Н О Н И М Н И   К Л А С О В Е :

Ползват се, когато имаме много разновидности от един абстрактен клас (или интерфейс), които се ползват само по веднъж.
Спестява създаването на клас с неговия файл само, за да бъде създаден един обект от него.

Директно се създава обекта от абстрактния клас (или интерфейс) и при самото му създаване се override-ват абстрактните методи. Този обект може да се ползва пълноценно в същия блок от код.
Ако ми трябват повече от 1 обект, тогава трябва да си създам истински клас.
Може да се създаде дори без променлива, която да сочи към него (референция), само колкото да свърши някаква работа. Но тогава трябва да дам .someCodeHere след затварящата скоба след override-ването "}".

Ползва се, защото ще имаме тепърва разни интерфейси, които ще имплементираме на различни места с леки вариации. И ще ги имплементираме често и по много.

СОРТИРАНЕ НА ЕЛЕМЕНТИ:
КОМПАРАТОР	- обект, който указва как се сравняват два от елементите на колекцията (List-а).


С Т Р У К Т У Р И   О Т   Д А Н Н И :

DATA STRUCTURES - купчини с елементи, които спазват някакви павила;
	-> Linear Data Structures
		-> List
			-> ArrayList
			-> LinkedList
		-> Stack
		-> Queue
	-> Tree
		-> Tree
	-> Table Data Structures
		-> Hash table

Структурите от данни се различават по сложност на операциите. Операциите са много, но основните са: add, remove, get, set, size, contains...

LIST - СПИСЪК
	-> ArrayList

		  0 1 2 3 4 5 6 7...
		[ -------------------------------- ]
		default 16 cells. Extends with +50% when needed. По подразбиране елемент винаги се добавя в края.
		.add е overload-нат метод на Arraylist. Ако подам само обект, го добавя в края. Ако подам индекс и обект, го добавя на указаното място (с ленейна сложност, защото измества всички останали).
		.set по същество редактира позицията на ArrayList, като замества съществуващия елемент с подадения в метода.

		add/remove (at end) 	-> constant complexity
		add/remove at start		-> linear complexity
		add/remove at middle	-> linear complexity

		get by index	-> constant complexity - достъпът до всички елементи е с константна сложност, защото е директно по индекс.
		set by index 	-> used for adding at start and in the middle in place of others
		add 			-> add at end or at index (избутвайки следващите елементи с един индекс напред)
		
		АНАЛОГИЯ: опашка с номерца в банката. Извикват No 34 и този номер се достъпва веднага от цялата тълпа.

	-> LinkedList (свързан списък)	- няма индекси. Всеки обект е свързан с друг.

		Обикновен Linked List	- всеки елемент държи референция само за обекта пред себе си (помни след кого е в опашката)
			TAIL		NODE		HEAD
			[] -> [] -> [] -> [] -> []
			Глава - първия на опашката.

		Double Linked List		- всеки елемент държи референция за обекта пред себе си и обекта след себе си (двата околни). Колекцията в JAVA е Double Linked List.
			TAIL		NODE			HEAD
			[] <-> [] <-> [] <-> [] <-> []

			add/remove (at end) 	-> constant complexity
			add/remove at start		-> constant complexity
			add/remove at middle	-> overall linear complexity, защото се добавям в средата с линейна сложност, но когато всеки пази само референция към съседа, мога да стигна до средата с линейна сложност.
									   това е обратното на ArrayList, където стигам константно до средата, но линейно вклинявам елемент.

			get by index get (5)	-> linear complexity - достъпът до първи и посл. ел. е с константна сложност. Достъпът до останалите е с линейна -  алгоритъма за почва от Head-а и пита всеки "Кой е следващия?"
			set by index 			-> used for adding at start and in the middle in place of others
			add 					-> add at end or at index (избутвайки следващите елементи с един индекс напред)
			
			АНАЛОГИЯ: чакане пред лекарски кабинет. Няма номера. Отивам и питам "Кой е последния" и се link-вам към него. 

QUEUE - ОПАШКА

			FIFO структура
			[] -> [] -> [] -> [] -> []
Има само 	add и 					get.
		add винаги добавя в края на опашката.
		get винаги взима първия елемент от опашката.
		няма как да поставим и да вземем от средата на опашката.

STACK

	LIFO (FILO) структура - First In Last Out
	add			remove
		\		/
		.........
		.........
		.........
		.........
		.........

В браузъра history-то представлява stack от URLs.
UNDO и REDO са два стека, като извадим от единия, слагаме в другия.
Добвянето и премахването са с константна сложноста.

В 95% ОТ СЛУЧАИТЕ ЩЕ ПОЛЗВАМ ARAYLIST. В 2-3% ЩЕ ПОЛЗВАМ LINKEDLIST (когато много често добавям и взимам само от началото или края на списъка, заради линейната сложност или когато искам да се държи като опашка
(LinkedList имплементира Queue, което е интерфейс).

TREE

Each element is a NODE.
Each element reacts to others as parent or child.
Each NODE has exactly 1 parent.
Each NODE can have 0 or more children.
Node without parents is ROOT.
Node without child is LEAF.
TREE DEPTH is the longest path from ROOTH to FARMOST CHILD.

BST - BINARY SEARCH TREE:
Each NODE can have 0, 1 or 2 children.
Each child is either LEFT or RIGHT.
Each LEFT child is lesser or equal to its PARENT.
Each RIGHT child is greater than its PARENT.

GRAPH
TREE in which a NODE can have more than one PARENT. В този случай може да има повече от един път между два елемента.
ДЪРВОТО е ГРАФ без цикли (ще го разбера като задълбая в "Структури от данни").

* Добавянето и премахването на елементи от дървото е с логаритмична сложност.
* Дървото (BST) автоматично дава сортирана структура.
* Затова задължително условие един елемент да влезе в едно дърво е той да е Comparable (да е сравним с останалите елементи).
* Ако подам предварително сортирани елементи, BST се изражда в Linked List.
  Поради това израждане, BST почти не се ползва. Ползва се BBST - (Balanced Binary Search Tree) Балансирано Бинарно дърво за Търсене.
  BBST преди да отвори нова дълбочина, първо проверява дали предната дълбочина е запълнена. Идеята му е при всякакви елементи да запази логаритмичната стойноста на добанявено, търсенето и премахването на елементи.
  RedBlack Tree е често срещана имплементация на BBST, която много се използва в колекциите в Java.

HASH-TABLE
ВСИЧКИ операции са с константна сложност (добавяне, изтриване, търсене)
Задължително условие, за да ползвам Hash-Table, е елементите да имплементират hash & equals, за да мога да предизвиквам колизии на всеки елемент и да проверявам дали той вече не съществува в таблицата според
зададените от мен критерии за уникалност (в hash & equals).



MAP
* Also called Dictionery.
* Key-Value pairs.




C O L L E C T I O N

Колекциите са Java обекти.
-> COLLECTION

	-> L I S T
В списъците могат да се съдържат повтарящи се елементи.
	
		-> ArrayList
				ArrayList<String> list = new ArrayList<>();
				ВИНАГИ ще оказвам типа обекти, които ArrayList-а ще приема чрез генеричен тип. В противен случай типа обекти ще ми е Object и ще мога да вкарвам всичко, но няма да мога да ползвам нищо без cast-ване.
				
		-> Vector - синхронизиран ArrayList (за да не се омаже кода, когато две нишки пипат по една колекция в многонишкова среда)
		
		-> LinkedList - not synchronized;
				LinkedList<String> list = new LinkedList<>();
				.addFirst(Object o) \ 
				.addLast(Object o)  / методи, характерни за свързания списък
				Имам и .add(int index, Object o) , но това първо обхожда с линейна сложност и след това вмъква с константна сложност.
				.removeFirst()
				.removeLast()
				.getFirst()		- взимаме главата на LinkedList-а.
				.getLast()		- взимаме опашката на LinkedList-а.
				
		-> Stack - за съжаление имплементира List и затова имам всички методи на List, например .add(). Пренебрегвам ги и работя само с болднатите, специфични методи (като push());
				Stack<String> list = new Stack<>();
					-> .peek 	- Взимам елемента, но не го махам(вадя) от стека. Така мога да видя кой/какъв е следващия елемент от стека и да преценя дали да го взема или не.
					-> .pop 	- връща следващия елемент и го вади от стека
					-> .empty	-
					-> .push	- поставя елемент в стека.
					-> .search
		-> Queue е интерфейс за разлика от останалите и не мога просто да създам обект от нея. Най-добре е да се имплементира по два начина:
			-> чрез PriorityQueue - приоритетна опашка
				Queue<String> queue = new PriorityQueue<>();
			-> чрез LinkedList - в общия случай
				Queue<String> queue = new LinkedList<>();
					-> .offer
					-> .poll	- връща следващия елементи и го вади от опашката. Същото прави и .remove, но при липса на елемент хвърля ексепшън, а .poll връща null.
					-> .peek 	- връща следващия елемент, но не го вади от опашката. Така мога да видя кой/какъв е следващия елемент от опашката и да преценя дали да го взема или не.
	
		* LIST Methods:
				.trimToSize() 		- ще провери колко е actual size на масива, ще я задели и ще премахне всички останали позиции, запълнени с null. Прави си, за да пести памет.
				.add(int index, Type element) - ДОБАВЯ на конкретна позиция като измества съществуващите, но не на такава, която не съществува, а само на такава, на каквато вече съм поставил елемент.
				.size()				- връща броят на поставени в списъка елементи;
				.addAll(Collection <> c)	- мога да взема цяла колекция и да я нанижа в този списък.
				.clear()			- изтрива всички елементи и set-ва size-а да е нула;
				.contains(Object o) - връща true/false според това дали подадения обект се намира в списъка;
				.remove()			- мога да трия конкретен обект от списъка или да трия по индекс (обекта, стоящ зад подадения индекс);
				.removeAll(Collection)		- Имам колекция "Софиянци" и втора колекция "Наркомани" и като дам Софиянци.removeAll(Наркомани) - от "Софиянци" ще изчезнат елементите, съдържащи се във втората колекция.
				.indexOf(Object o)	- връща Integer - на коя позиция в списъка се намира подаденият обект.
				.isEmpty()			- boolean - връща дали има елементи в списъка;
				.replace()
				.replaceAll()
				.sort(Comparator<E> c)
			
			
			

	-> S E T		(интерфейс) - колекция, която съдържа само уникални елементи; Методът .add() връща true или false според това дали елементът е добавен или е игнориран, понеже вече се съдържа.
					Интерфейсът Set се реализира чрез два основни класа - TreeSet и HashSet.
	
		-> TreeSet 0(log), sorted, needs to be comparable
			Конкретен клас, чрез който се реализира колекцията (интерфейс) Set.
				- ограничение	- добавянето е с логаритмична сложност, вместо с константна;
				- печелим		- подредбата на елементите ни е гарантирана. Елементите при TreeSet<String> се сортират така, както по подразбиране се сравняват String-овете.
				- задължението	- когато искам да вкарам нещо в дървовидна колекция, то трябва да имплементира Comparable. Ако не го направя, се компилира, но гърми Class Case Exception;
								- когато имплементирам Comparable, съм задължен да реализирам .compareTo() По подразбиране е return 0; Ако го оставя така, в колекцията ще влезе само първият елементи и ще отхвърли
								всички останали, защото приема, че всеки следващ е равен на първия. Ако върна 1 (return 1), това означава, че всеки елемент е по-голям от подадения и всички ще влязат.
			
			Set implemented by tree			-> unique elements, constant complexity, ;
											-> mandatory Comparable implementation for elements type
											
			Eлементите на TreeSet-а задължително трябва да имплементират интерфейса Comparable(), който да оказва как да се стрявни this с other елемент.
			Мога да използвам и Comparator при дефинирането на TreeSet-a. В него с ламбда подавам как да се сравняват (и разграничават) елементите в сета.
			Ако искам TreeSet, сортиран по три различни начина - създавам три нови TreeSet-а с необходимите компаратори и копирам оригиналния във всеки от тях.
			Мога да го направя и с ArrayList. Тогава самият ArrayList чрез .sort мога да си го сортирам три пъти подред. Нямам нужда от втори и от трети (но тогава нямам уникални елементи, в случай, че ми трябват).

		-> HashSet 0(1), unordered, needs to have good hashCode and equals implementations.
			Set implemented with Hash Table	-> unique elements, logarithmic complexity, sorted result;
											-> mandatory Comparable implementation for elements type
				HashSet<String> set = new HashSet<>();
			-> LinkedHashSet - still not sorted, but ordered - елементите се появяват в реда на въвеждането им (без значение кой в кой бъкет е попаднал).
			
	Винаги се старая да ползвам HashSet при нужда от уникални елементи, защото е най-бърз. Когато ми трябва подредба, жертвам бързината, за да я получа - с TreeSet.


	-> M A P
	
		-> TreeMap -> 0(log), sorted, keys have to be comparable.
			В Map-a, когато подам ентри със съществеващ ключ, то презаписва старото значение по този ключ. Не пази двете стойности. Ако искам да запазя повече от една стойности, мога да направя List в Map:
			TreeMap<String, List<String>) map = new TreeMap<>(); - така срещу всеки ключ стои списък със значения.
					-> .put(K, V) 		- приема двойка стойности (entry - обект от клас, който е вътрешен за Map-а) и това е един елемента на Map-a.
					-> .size			- връща броя ентрита.
					-> .entrySet() 		- връща сет от ентритата на мап-а
					-> .firstEntry()	- 
					-> .lastEntry()		- 
					-> containsKey(K)	- ако искам да проверя дали един ключ съществува, го проверявам с containsKey(K);
					-> containsValue(V)	- 
					
				

		-> HashMap -> 0(1), unordered, keys have to implement hashcode and equals.
					-> putAll(Map) 		- мога да налея един Map в друг Map;
					-> putIfAbsent(K, V)	- поставя го ако няма такъв ключ. Ако има, не го поставя, за да не презапише оригиналната стойност.
					-> get(Key)			- връща значението, стойността зад ключа;
					-> containsKey(Key)	- връща дали има такъв ключ в мапа.
					-> containsValue(Value)	- връща дали има такава стойност зад някой ключ в мапа.
					-> size()			- връща броя на ключ-стойност двойките (entries)
					-> entrySet()		- връща сет от ентритата(K, V) на мап-а.
					-> keySet()			- връща сет от ключовете на мап-а.
					-> values()			- връща колекция от стойностите.
		Капацитета на HashMap-а e малко над 1 милиард ентрита (1 << 30).
		Ентрито е обект от клас, който е вътрешен за мап-а (използва се само от него).
					
		Как да покажа map (напр. TreeMap) на екрана - ПРАВИЛНО (линейна сложност):
		for (map.Entry<Key,Value> e: map.entrySet()) {
			System.out.println(e.getKey() + " - " + e.getValue());
		}
		Как да покажа map (напр. TreeMap) на екрана - НЕПРАВИЛНО (линеаритмична сложност(първо линейно обхожда всички елементи, и за всеки елемент намира стойността му с логаритмична сложност)):
		for (map.key e: map.keySet()) {
			System.out.println(key + " - " + map.get(key));
		}
					

* При HashMap и HashSet трябва да override-на hash-code-а да зависи от нещо турбо уникално. Най-голямата ми грешка ще е да зависи от повтарящ се признак, защото така от два различни елемента, при които този признак
се повтаря, в структурата данни ще попадне само първия, т.к. .equals ще сметне обектите за еднакви по същия признак и ще изхвърли втория (и всеки следващ със същата стойност).

* Докато при TreeSet и HashSet дублиращите елементи се игнорират, при TreeMap и HashMap, дублиращите елементи презаписват value-то на стария елемент.

* В TreeMap, containsKey() метода няма да ми работи правилно, ако не съм си написал хубаво comapeTo() метода.

List - линейно подредени елементи, динамични масиви.
ВИНАГИ ПОЛЗВАМ List. В 95% от слуаите ползвам ArayList.
Когато искам да си гарантирам, че в листа се съдържат само уникални елементи, ползвам Set.

ВИНАГИ ПОЛЗВАМ HashSet, защото е най-бърз (с изключение на структури от многомилионни елементи). Когато, обаче ми трябва подредба, ползвам TreeSet - жертвам бързина за сортировка.

к л а с   C o l l e c t i o n s :

Collections.UnmodifialbleList	- изключително добра практика на места, на които не искам никой да пипа след мен.

LinkedHashSet работи като HashSet. Единствената разлика е, че при обхождане на елементите, те се появяват в реда, в който съм ги добавил (без значение в кой bucket са влезли). Not sorted, but ordered.

	COLLECTION METHODS:
		
	
		* int size();							- връща броят на елементите;
		* boolean isEmpty();					- връща дали колекцията е празна;
		* boolean contains(Object o);			- връща дали колекцията съдържа даден обект;
		* Iterator<E> iterator();				- 
		* Object[] to Array();					- прехвърля елементите на колекцията в масив;
		* boolean add(E e);						- добавя елемент, който е от генеричен тип на самата колекция и връща true ако елемент е добавен;
		* boolean remove (Object o);			- премахва елемент от колекцията;
		* boolean removaAll(Collection <?> c)	- Премахва всички елементи на посочената колекция, които се съдържат в основната колекция.
		* boolean retainAll(Collection <?> c)	- Премахва от основната колекция всички елементи, освен тези, които се съдържат в посочената колекция (тях ги запазва).
		* removeIf(Predicate)					- 
		* clear()								- премахва всички елементи.;
		
UnmodifiableList 		- немодифицируемите листове са много добра практика за места, на които не искам никой да пипа.
UnmodifiableSet			- 
UnmodifiableMap			- .add .edit .clear .remove .set ще хвърлят unsupported operation exception
UnmodifiableCollection	- 

A U T O B O X I N G :

	byte		->		Byte
	short		->		Short
	int			->		Integer
	long		->		Long
	float		->		Float
	double		->		Double
	char		->		Character
	boolean		->		Boolean

	AUTOBOXING		-> 	automatic transformation from primitive value to an instance of the wrapper.
	AUTOUNBOXING	-> 	automatic transformation from an instance of the wrapper to primitive value.

Никога да не извършвам аритметични опирации с Wrap-ове. Никога не ми трябват Wrap-ове, за да си играя с числа. Трябват ми само при колекции или други контейнери.


ITERATOR

Iterator е обект, който се грижи да итерира колекцията. Всяка колекция има Iterator. Той е pointer, показалец, който във всеки един момент сочи към един от елементите на колекцията 
и когато го преместя мога да разчитам, че ще сочи към следващия по ред елемент.
За разлика от forEach, с Iterator мога да обхождам отзад-напред, мога да изтривам елементи от колекцията, ако отговарят на дадено условие.

Принтиране на елементите на TreeSet:
	for(Iterator<String> it = set.iterator(); it.hasNext();){
		String element = it.next();
		System.out.print(element);
		... do some other stuff with element...
	}
		ИЛИ
	for(String s: set) {
		System.out.print(s);
		... do some other stuff with element...
	}
	

	* Винаги трябва да ползвам итератора като локална променлива. Грешка е да ползвам един итератор за втори път, защото той си помни позицията и към края на първата итерирана колекция вече е deplete-нат.
	* set.iterator()	- инициализира чисто нов итератор, който сочи в нищото (една позиция преди първия, нулев елемент).
	
	Методи на итератор:
		- hasNext()
		- next()
		- remove() 	- докато итерира, итераторът може да премахва елементи от колекция и това е единственият начин да го направя прецизно елемент по елемент. 
					Ако обхождам с обикновен цикъл една колекция и давам delete, ще счупя колекция. Повечето колекции в такъв случай хвърлят Concurent modification exception, т.е. модифицират колекцията, докато
					я обхождам (докато един я обхожда, друг пипа по нея).
	!!! iterator.next() се вика САМО ВЕДНЪЖ на итерация. в противен случай ще се итерира през елемент (два, три...) и логиката няма да обхване всеки от елементите.
	
	set.iterator().next() - връща първия елемент - еквивалент на get(0) при листовете. Същото прави и set.pollFirst();
	
	
S T R E A M S :

Стриймовете са по-бавни от обикновените цикли, но са много добри при огромни колекции и при паралелизация (могат да се възползват от многонишковото програмиране).